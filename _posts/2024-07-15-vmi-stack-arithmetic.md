---
layout: posts
title: "Nand2Tetris - 07 | VM I: Stack Arithmetic"
categories: computer-projects
---
Writing a program that translates the arithmetic and memory access instructions of an intermediate, stack-based VM language into Hack assembly. This will later become the backend tier of a compiler for the high-level language Jack.
<br><br>
<a href="https://www.nand2tetris.org/project07" target="_blank">Project specifications</a> | <a href="https://github.com/wangzi190/nand2tetris/tree/master/07" target="_blank">My work</a>
<br><br><b>Concepts</b>
<br><br>Computer programs written in high-level language must be compiled into the machine code of a target hardware plaform before they can be run on said platform. For the sake of modularity, some compilers perform the compilation process in two distinct partsâ€”first, it translates high-level language to an intermediate code; then, it translates the intermediate code to machine code.This is lucrative because there then does not need to be a new compiler written for each high-level language and hardware platform pair; instead, languages and hardware can be mixed and matched so long as both are compiled to the same intermediate language.
<br><br>In the Nand2Tetris course, this intermediate language is referred to as "VM code" because it is carefully specified and complex enough to run on its own virtual machine. This VM code embodies the stack machine model, meaning its working memory is a LIFO (last in, first out) data structure called the <i>stack</i>. Accordingly, the VM language includes <i>push</i> (put [some value] onto the stack) and <i>pop</i> (remove the stack's topmost value, and store it at [some value]) memory access commands, as well as branching, subroutine calling, and arithmetic and logical operations. Here, I implement the arithmetic, logical, and memory access instructions.
<br><br><b>Process</b>
<br><br>The most involved part of this project wasn't writing the code, but more rather understanding the intermediate code specifications and translating it appropriately to Hack assembly. Also, since this project will be expanded upon in the next, I decided not to include syntactical error-handling in my program (for now, lest I make adding new functionalities difficult), which also made it simpler to write.
<br><br><i>Assembly Language Mistakes</i>
<br><br>In trying to write the assembly language pertaining to each VM command, I mistakenly read and wrote data to the memory at the stack pointer instead of the memory at the value stored at the stack pointer (The stack pointer, like its name suggests, is the register that stores the address at which the next stack element should be put). And later, when trying add access to the pointer and temp memory segments, I accidentally loaded the contents of RAM[5] into the A register instead of the constant 5 itself (The <i>n</i>th temp register is at 5 + n; thus, this operation is required to calculate the position at which I should be storing certain data). These mistakes were both very easy to fix once I'd realized what went wrong.
<br><br><i>Generating Program Labels</i>
<br><br>Another silly mistake I'd made had to do with generating labels in my translated assembly code. Basically, I decided to use Hack assembly's conditional jump instructions to determine the output for each eq, gt, and lt (equal to, greater than, and less than) stack operation. To go at this, I'd set the output value as 0x0000, aka false, by default. Then I'd retrive the two topmost stack values, subtract one from the other, and use a D;JEQ (jump if D=0), D;JGT (jump if D>0), or D;JLT (jump if D<0) instruction to jump to a special snippet of assembly code (marked by a program label) that'd change the output value to 0xFFFF, aka true. When I ran my translator program and tested the code, I found that I'd forgotten to generate unique labels for the "change to true" snippet of each eq, gt, and lt operation. Again, this was also a pretty simple fix.
<br><br><b>Additional Comments</b>
<br><br>Though I was able to perform a 1-to-1 translation from VM code to assembly code, simplifying the translation process, there is still some redundancy in the generated instructions. For example, the <i>push</i> operation is always set to increment the stack pointer after pushing a new value to the stack. However, if followed by an arithmetic instruction like <i>add</i>, it'll then decrement the stack pointer again anyway. I wonder whether or not it's more worthwhile to complicate the translation process to reduce the number of generated assembly language instructions. Which should we value more, and in what cases? What are the tradeoffs?
<br><br>Also, I feel like I went a little overboard with the parentheses this time, but hopefully by doing so I made things clearer :')